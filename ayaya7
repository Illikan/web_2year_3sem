def get_filtered_stations(study_date: datetime):
    """
    БЫСТРАЯ функция для инициализации сессии.
    1. Получает список всех станций из H5 файла.
    2. Асинхронно загружает их координаты.
    3. Фильтрует станции по близости к аномалии.
    Возвращает отфильтрованный список словарей с данными о станциях.
    """
    print(f"Инициализация сессии для {study_date.date()}. Фильтрация станций...")
    DISTANCE_LIMIT_KM = 3000.0 

    try:
        h5_file_path = load_h5_data(study_date)
        if not h5_file_path:
            raise FileNotFoundError("Не удалось загрузить H5 файл для получения списка станций.")
        
        with h5py.File(h5_file_path, 'r') as f:
            all_stations_in_h5 = list(f.keys())
        
        print(f"Найдено станций в H5: {len(all_stations_in_h5)}. Загружаю координаты...")
        all_stations_data = asyncio.run(get_all_site_data_concurrently(all_stations_in_h5))
        
        anomaly_poly_coords = generate_equatorial_poly()
        anomaly_s2_loop = s2.S2Loop([
            s2.S2LatLng.FromDegrees(lat, lon).ToPoint() for lon, lat in anomaly_poly_coords
        ])
        anomaly_polygon_s2 = s2.S2Polygon(anomaly_s2_loop)

        relevant_stations = []
        for site_data in all_stations_data:
            if is_site_near_anomaly_s2(
                site_latlon=(site_data['lat'], site_data['lon']),
                anomaly_polygon_s2=anomaly_polygon_s2,
                max_distance_km=DISTANCE_LIMIT_KM
            ):
                relevant_stations.append(site_data)
        
        print(f"После фильтрации осталось {len(relevant_stations)} станций.")
        return relevant_stations

    except Exception as e:
        print(f"Критическая ошибка при фильтрации станций: {e}")
        return []


# ==============================================================================
# НОВАЯ ФУНКЦИЯ №2: find_next_valid_segment
# ==============================================================================
def find_next_valid_segment(study_date: datetime, station_list: list, current_station_idx: int, current_sat_idx: int):
    """
    "Ленивая" поисковая функция. Ищет следующий валидный сегмент,
    начиная с указанной позиции в списке станций и спутников.
    Возвращает (метаданные_сегмента, новый_индекс_станции, новый_индекс_спутника) или (None, None, None).
    """
    print(f"\nПоиск следующего сегмента, начиная со станции #{current_station_idx}, спутника #{current_sat_idx}...")
    
    try:
        nav_file = load_nav_file(study_date)
        if not nav_file: raise FileNotFoundError("Не удалось загрузить NAV файл для поиска сегмента.")
        h5_file_path = load_h5_data(study_date)
        if not h5_file_path: raise FileNotFoundError("Не удалось загрузить H5 файл для поиска сегмента.")
        
        end_time = study_date + timedelta(days=1, seconds=-30)
        anomaly_poly_coords = generate_equatorial_poly()
        anomaly_s2_loop = s2.S2Loop([
            s2.S2LatLng.FromDegrees(lat, lon).ToPoint() for lon, lat in anomaly_poly_coords
        ])
        anomaly_polygon_s2 = s2.S2Polygon(anomaly_s2_loop)
    except Exception as e:
        print(f"Ошибка при подготовке к поиску сегмента: {e}")
        return None, None, None

    # Итерируемся по станциям, начиная с текущей
    for i in range(current_station_idx, len(station_list)):
        site_data = station_list[i]
        
        with h5py.File(h5_file_path, 'r') as f:
            available_sats = list(f.get(site_data['id'], {}).keys())
        
        # Если мы на новой станции, начинаем с первого спутника. Иначе - продолжаем.
        start_sat_idx = current_sat_idx if i == current_station_idx else 0
        
        print(f"--- Проверка станции {site_data['id'].upper()} (спутники с #{start_sat_idx}) ---")

        # Итерируемся по спутникам этой станции
        for j in range(start_sat_idx, len(available_sats)):
            sat_id = available_sats[j]
            
            # --- ЗАПУСКАЕМ ТЯЖЕЛЫЕ ВЫЧИСЛЕНИЯ ТОЛЬКО ДЛЯ ОДНОЙ ПАРЫ ---
            all_sats_xyz, times = get_sat_xyz(nav_file, study_date, end_time, sats=[sat_id])
            if not all_sats_xyz: continue
            
            sats_elaz = get_elaz_for_site(site_data['xyz'], all_sats_xyz)
            if sat_id not in sats_elaz: continue
            
            elaz_data = sats_elaz[sat_id]
            visible_mask = elaz_data[:, 0] > 0
            if not np.any(visible_mask): continue
            
            sips_coords = calculate_sips(np.radians(site_data['lat']), np.radians(site_data['lon']), elaz_data[visible_mask, 0], elaz_data[visible_mask, 1])
            points_with_datetime = [{'lat': sip[0], 'lon': sip[1], 'time': time} for sip, time in zip(sips_coords, np.array(times)[visible_mask])]
            
            time_based_segments = split_trajectory_by_gaps(points_with_datetime)

            part_number = 1
            for segment in time_based_segments:
                is_valid, intersections = is_segment_valid(segment, anomaly_polygon_s2)
                if is_valid:
                    # НАШЛИ!
                    print(f"    ✅ Найден валидный сегмент: {site_data['id']}-{sat_id} (часть {part_number})")
                    segment_id = f"{site_data['id']}-{sat_id}-{part_number}"
                    
                    full_segment_data = {
                        'id': segment_id,
                        'points': [{**p, 'time': p['time'].isoformat()} for p in segment],
                        'intersections': [{**p, 'time': p['time'].isoformat()} for p in intersections]
                    }
                    cache_segment_data(segment_id, full_segment_data)
                    
                    event_metadata = {
                        'id': segment_id,
                        'station_id': site_data['id'],
                        'satellite_id': sat_id,
                        'entry_time': intersections[0]['time'].isoformat(),
                        'exit_time': intersections[-1]['time'].isoformat(),
                        'has_effect': False 
                    }
                    
                    # Возвращаем метаданные и НОВЫЕ индексы для СЛЕДУЮЩЕГО поиска
                    return event_metadata, i, j + 1
                
                part_number += 1

    # Если мы прошли все циклы и ничего не нашли, значит, разметка закончена.
    print("Поиск завершен. Больше валидных сегментов не найдено.")
    return None, None, None
